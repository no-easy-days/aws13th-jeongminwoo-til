## Stateless (무상태)
- 서버가 클라이언트의 이전 요청을 기억하지 않는 상태
## 쿠키
클라이언트가 어떠한 웹사이트를 방문할 경우 그 사이트가 사용하고 있는 서버를 통해 쿠키를 생성하여   
-> 클라이언트의 브라우저에 설치되는 작은 기록 정보 파일 (웹 브라우저가 보관하는 데이터)  


### <쿠기 동작 방식>
<img width="645" height="399" alt="스크린샷 2026-01-09 오후 2 06 06" src="https://github.com/user-attachments/assets/fd217130-a374-43b6-be68-311ec0ea198a" />

1) 클라이언트가 페이지를 요청
2) 서버에서 쿠키를 생성
3) http헤더에 쿠키를 포함시켜 응답
4) 브라우저가 종료되도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음
5) 같은 요청을 할 경우 http헤더에 쿠키를 함께 보냄
6) 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을때 쿠키를 업데이트하여 변경된 쿠키를 다시 http헤더에 포함시켜 응답

## 세션 
-쿠키를 기반으로 하고 있지만 사용자 정보파일을 브라우저에 저장하는 쿠키와 달리 서버측에서 관리

### <세션 동작 방식>
<img width="669" height="364" alt="스크린샷 2026-01-09 오후 2 11 04" src="https://github.com/user-attachments/assets/e0c75cc1-4d35-4406-978c-b9ebe985e1da" />

1)클라이언트가 서버에 접속 시 세션 ID를 발급 받음  
2)클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있음   
3)클라이언트는 서버에 요청할 때 이 쿠키의 세션 ID를 같이 서버에 전달해서 요청   
4)서버는 세션 ID를 전달 받아서 별다른 작업없이 세션 ID로 세션에 있는 클라아이언트 정보를 가져와서 사용  
5)클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답   

## JWT(JSON Web Token)
-JWT : 인증에 필요한 정보들을 인코딩시킨 토큰(데이터를 json형태로 담아 만든 토큰)   
-JWT 토큰(Access Token)을 HTTP 헤더에 담아 서버가 클라이언트를 식별한다.

JWT를 보면 .을 기준으로  [header].[payload].[signature] 이렇게 나뉘어 있다.   
여기서 [payload] 내용물을 복호화(Decode)하면 내 아이디,이름 유효기간 등이 들어있다. (누구나 뜯어볼 수 있다.) 

Encode - 컴퓨터가 통신하기 편한 형태(문자열)로 변환하는 것이다.  
복호화(Decode)란? - 암호를 풀어서 다시 읽을 수 있는 상태로 만드는 것이다.

[signature] : Header와 Payload를 합친 뒤 서버만 알고 있는 비밀키로 섞어서 만든 복잡한 코드이다.  
(예를 들어 사장님이 카드 뒷면에 본인만 아는 비밀 도장을 꽝 찍어놓은 것이다.)  
따라서 다른 사람이 건들이면 [signature]가 다르게 나오기 때문에 걸린다. 

### <동작 방식>
1) 사용자가 로그인 요청을 보냄
2) 서버는 요청이 들어오면 사용자 검증을 통해 유효성을 확인하고 토큰을 응답과 함께 반환
3) 클라이언트는 토큰을 저장, 서버 요청 시 토큰을 request header에 담아 서버에 요청을 보냄
4) 서버는 토큰을 검증 후 요청에 응답

## Authorization Header
-클라이언트가 서버에 자신이 어떤 자격 증명(인증 정보)을 가진 유효한 사용자인지 증명하기 위해 HTTP 요청 시 함께 보내는 헤더이다.  
## 비유
. 쿠키 (Cookie): 손님 주머니(브라우저) 속 스탬프 쿠폰
사장님이 손님이 누군지 기억하기 귀찮아서 손님 주머니에 '단골 메모'를 하나 넣어준다.  

상황: 메모지에 "이 손님은 연하게 마심"이라고 적어둔다. 나중에 메모지를 사장에게 보여주면 연하게 마시는걸 안다  
-정보가 손님 주머니(브라우저)에 있다.

. 세션 (Session): 카페 카운터 뒤의 회원 장부  
사장님이 가게 안에 커다란 장부(서버)를 하나 만들었다.  

상황: 손님에게는 '회원번호 5번'이라고 적힌 카드(세션 ID)만 준다.  
손님이 오면 '5번 카드'를 사장님께 보여준다. 사장님은 가게 장부 5번 칸을 보고 "아, ***님! 평소처럼 연하게 드릴까요?"라고 묻는다.

-정보는 가게 장부(세션)에 있고 손님은 그 정보를 찾기 위한 번호표(쿠키)만 들고 다닌다.

. JWT (JSON Web Token): 위조 방지 바코드가 찍힌 선불 카드
카페가 너무 잘 돼서 2호점, 3호점을 냈는데 분점 직원은 본점 장부를 볼 수가 없다. 그래서 사장님이 특수 바코드가 찍힌 카드를 발행한다.

상황: 카드 안에는 "이름: 김철수, 혜택: 샷 추가 무료"라는 정보가 암호화되어 들어있고 사장님만 찍을 수 있는 홀로그램(서명)이 붙어 있다.
손님이 2호점에 가서 이 카드를 보여주면 직원은 본점에 전화해서 장부를 물어볼 필요가 없다. 그냥 홀로그램이 진짜인지만 확인하고 카드에 적힌 대로 서비스를 해준다.

-장부를 확인할 필요 없이 카드(토큰) 그 자체로 신분이 증명된다.

. Authorization Header : 카드,번호표를 내미는 행위


## 장단점 
*세션*   
장점:  

1.즉각적인 제어 가능 : 서버에서 해당 세션을 지워버리면 즉시 접속이 차단된다.  
2.상대적 보안 우위 : 클라이언트(브라우저)에는 아무 의미없는 번호표만 있으므로 유의미한 정보 노출 가능성이 낮다.  
3.데이터 최신화 : 사용자의 정보가 변경되면 서버 장부만 수정하면 즉시 반영된다.  

단점:  

1.서버 부하 : 접속자가 많아질수록 서버 메모리를 많이 차지한다.  
2.확장성 문제 : 서버가 만약 2대라면 서버로 요청을 보냈을 때 장부가 없어 인증이 안된다.   
  
*JWT*   
장점:    

1.서버 자원 절약(무상태):서버는 장부를 뒤질 필요가 없다. 토큰만 확인하면 되므로 서버 메모리를 거의 쓰지 않는다.  
2.확장성 우수 : 여러 대의 서버가 있어도 검증할 토큰만 있어도 어디서든 인증이 가능하다.  

단점:   

1.즉각적 제어 어려움 : 특정 토큰을 만료될 때까지 서버가 강제로 취소시키기 어렵다.(장부가 없어서 지울수 없음)  
2.데이터 크기 : 토큰의 길이가 늘어날수록 네트워크에 부하를 줄 수 있다.


